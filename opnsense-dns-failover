#!/usr/bin/env python3
import sys
import json
import requests
import CloudFlare
import time
import ipaddress
from datetime import datetime

from config import *

# Sample of output from opnsense gateway status endpoint
"""
{'items':
    [
        {'name': 'WAN1_DHCP', 'address': '1.2.3.4', 'status': 'none', 'loss': '0.0 %', 'delay': '7.0 ms', 'stddev': '0.2 ms', 'status_translated': 'Online'},
        {'name': 'WAN2_DHCP', 'address': '5.6.7.8', 'status': 'none', 'loss': '0.0 %', 'delay': '17.4 ms', 'stddev': '0.2 ms', 'status_translated': 'Online'}
    ],
    'status': 'ok'
}
"""

"""
Possible status values:
      - none: online
      - force_down: forced offline manually
      - down: offline
      - delay: Latency
      - loss: Packetloss
      - delay+loss: Latency,Packetloss
"""

def d(s):
    if DEBUG:
        _l(f"[DEBUG] {s}")

def l(s):
    _l(f"[LOG] {s}")

def e(s):
    _l(f"[ERROR] {s}")

def _l(s):
    dt = datetime.now().replace(microsecond=0).isoformat()
    print(f"[{dt}] {s}")

def opnsense_get_gateways():
    try:
        r = requests.get(f"https://{ROUTER_HOSTNAME}/api/routes/gateway/status", auth=(OPNSENSE_KEY,OPNSENSE_SECRET), verify=SSL_VERIFY)
        gateways = r.json()['items']
        d(f"Gateways obj: {gateways}")
        return gateways

    except:
        return False

def opnsense_get_interfaces():
    r = requests.get(f"https://{ROUTER_IP}/api/interfaces/overview/interfacesInfo", auth=(OPNSENSE_KEY,OPNSENSE_SECRET), verify=False)
    interfaces = r.json()['rows']
    d(f"Interfaces obj: {interfaces}")
    return interfaces

def get_interface_ip(interface_name, interfaces):
    for iface in interfaces:
        if iface['description'] == interface_name:
            return iface['ipv4'][0]['ipaddr'].split('/')[0]

def update_dns(ip):
    try:
        if ipaddress.ip_address(ip).is_private:
            e(f"Passed an RFC1918 IP to update_dns, ignoring")
            return False
    except ValueError:
        e(f"Invalid IP address passed to update_dns: {ip}")
        return False
    if not ip:
        e(f"update_dns called with empty IP")
        return False
    try:
        cf = CloudFlare.CloudFlare(token=CLOUDFLARE_TOKEN)
        zones = cf.zones.get(params={'name':'mantup.com'})
        if not zones:
            e("Could not retrieve DNS zone for domain")
            return False
        zone_id = zones[0]['id']
        dns_records = cf.zones.dns_records.get(zone_id, params={'name':TARGET_URL, 'type':'A'})
        if not dns_records:
            e("Could not find existing record in zone")
            return False
        record_id = dns_records[0]['id']
        d(f"DNS Record\n:{dns_records[0]}")
        new_record = {
            'name' : TARGET_URL,
            'type' : 'A',
            'content' : ip,
            'proxied' : False
        }
        cf.zones.dns_records.put(zone_id, record_id, data=new_record)
        l(f"Updated CF record for {TARGET_URL} to IP {ip}")
        return True
    except Exception as e:
        e(f"update_dns got exception: \n{e}")
        return False


def get_gateway_state():
    gateways = opnsense_get_gateways()
    if not gateways:
        raise Exception("No gateways from OPNsense")

    primary_found = False
    secondary_found = False
    primary_is_up = False
    secondary_is_up = False
    for g in gateways:
        if g['name'] == CONFIG['primary_gateway']:
            primary_is_up = g['status'] in ['delay', 'none']
            primary_found = True
        if g['name'] == CONFIG['secondary_gateway']:
            secondary_is_up = g['status'] in ['delay', 'none']
            secondary_found = True

    if not primary_found:
        e(f"Primary gateway {CONFIG['primary_gateway']} is missing from OPNsense's gateway report -- considering it down")
    if not secondary_found:
        e(f"Secondary gateway {CONFIG['secondary_gateway']} is missing from OPNsense's gateway report -- considering it down")

    return (primary_is_up, secondary_is_up)

def main():
    l("Starting OPNsense dynamic DNS failover monitor")
    if not SSL_VERIFY:
        # Ignoring warnings generated by urllib skipping verification of self-signed SSL certs
        import warnings
        warnings.simplefilter("ignore")

    currently_degraded = False
    currently_down = False

    # TODO: Validate the gateways in the config exist
    while True:
        try:
            primary_is_up, secondary_is_up = get_gateway_state()
        except:
            e(f"Error getting gateway state; will retry")
            time.sleep(SLEEP)
            continue

        # Covers both primary going down, and secondary coming back up after a total outage
        # Either way the record needs to point to secondary now.
        if not primary_is_up and not currently_degraded:
            if secondary_is_up:
                l(f"Primary {CONFIG['primary_interface']} seems to be down, but secondary is up; changing record to point to secondary {CONFIG['secondary_interface']}")
                if update_dns(get_interface_ip(CONFIG['secondary_interface'], opnsense_get_interfaces())):
                    currently_degraded = True
                    currently_down = False
                else:
                    e(f"Could not update DNS record; will retry")
            elif not currently_down:
                currently_down = True
                e(f"Primary {CONFIG['primary_interface']} has gone down, but secondary {CONFIG['secondary_interface']} is down too! Doing nothing as internet is likely unreachable.")

        # Covers primary coming back up
        elif (currently_degraded or currently_down) and primary_is_up:
            l(f"Primary {CONFIG['primary_interface']} is (back) up; setting record to point to primary")
            if update_dns(get_interface_ip(CONFIG['primary_interface'], opnsense_get_interfaces())):
                currently_degraded = False
                currently_down = False
            else:
                e(f"Could not update DNS record; will retry")

        time.sleep(SLEEP)

if __name__ =='__main__':
    main()
